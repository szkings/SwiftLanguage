###读薄The Swift Programming Language


####一、基础部分
万丈高楼平地起——**swift地基：基本数据类型**

* [基础数据类型5个，基本集合类型3个，高级类型2个]()
* [常变量名不能包含5种字符，不能一数字开头]()
* [整数有有符号和无符号两种，有4种不同长度位。特殊类型Int、UInt]()
* [整数字面量4种表示，浮点字面量2种表示]()
* [Tupe的2种创建和2种访问方式]()
* [Swift nil 和Objective-C中nil的区别]()
* [断言使用的3种情景和使用的目的]()





ps: 1.常不变，变可变；强类型，先声明，后使用；多个量，在一行，逗隔开；类标注，及少用，智能法，可推断








#####详解一
Int、String、Bool、float、double；Array、Set、Dictionary



#####详解二
数字符号，箭头，保留的(或者非法的)Unicode码位，连线，制表符

#####详解三
8、16、32、64位。Int与平台有关，长度与当前平台的原生字长相同。
推荐使用Int，不推荐是UInt

#####详解四
十、二、八、十六进制。数值字面量可以添加额外的格式，比如0，_来增强可读性


---

**问题：浮点的数据类型，范围、表示、底层二进制表示，补码等等**





---
####二.基本运算符
检查、改变、合并值的特殊符号或短语。

* 根据运算符操作的元素个数，可以分三类：一元（前置、后置）、二元（中间）、三元运算符(一个)
* 根据结果来分类有8种：
   1. 赋值运算符“=”，赋值后不返回任何值，避免"=="混淆：
   2. 算术运算符
      1. 四则(+、-、*、/)，默认下数值出现溢出会报错
      2. 求余运算符"%"(a%b),当b为负数时，可以忽略其符号，浮点可以求余
      3. 自增、自减运算（--、++），可以前、后置，它们的返回值不同。推荐使用前置
      4. 一元正、负运算符
   3. 组合赋值和（=）组合后一起使用
   4. 比较运算符6种（等、不等、大、大等、小、小等）。注意“===”使用在对象是否相等上面
   5. 三目运算符 “？ :”
   6. 空合运算符(a??b),a是可选类型，b是其对应的值
   7. 区间运算符：闭区间、半开区间
   8. 逻辑运算符（与、或、非）
      
---


**问题：值溢出**

---      

####三、字符串和字符
有序字符（Character）类型的值的集合

* 字符串字面量（“”包裹的文本字符集）用于提供初始值（可包含10种特殊字符）
* 空串的创建2种方法和判断（isEmpty属性）
* 字符串是值类型，在对其赋值、传递时都会拷贝
* 字符的创建、从字符串获取字符、字符数组构建字符串、字符串添加字符
* 字符串插值构建新字符串（括号中不能包含3种字面量：“\,回车、换行符”）
* 字符串索引
* 字符串插入和删除
* 字符串比较3种方式（相等、前缀、后缀相等）



---


**问题：Stirng和 NString的联系   ； Unicode作为了解阅读**

---   



####四、集合
Array集合特性：有序数据集合；Set特性：无序无重复数据集合；Dictionary：无序键值对集合。Set集合中的值的类型必须可哈希，Dictionary中的key必须可哈希

* 集合的可变型，常量都不可以变，变量随意变
* 数组创建的4种方式
* 数组的访问和修改常见8种操作
    1. 数据数量、
    2. 为空、
    3. 添加新数据项2种方式
    4. 改变指定值、
    5. 改变一系列值、
    6. 插值、
    7. 删值、删除最后一个值
    8. 数组的2种遍历
* 创建集合2种方式
* 集合的访问和修改常见操作7种
     1. 数据数量
     2. 为空
     3. 添加新数据
     4. 删除一个数据
     5. 包含特定数据
     6. 集合的2种遍历
     7. 集合之间的操作4种关系、父子之间关系5种
* 创建字典的2种方式
* 字典的访问和修改常见操作9种操作
     1. 数据数量
     2. 为空
     3. 添加新数据项2种方式
     4. 更新数据项值2种方式
     5. 获取数据项的值
     6. 删除一个键值对2种方式
     7. 遍历字典
     8. 遍历字典的keys或者values
     9. 使用keys或者values构建数组








#####详解一
空数组、带默认值的数组、两个数组相加、字面量构造




---


**问题：哈希知识扩展及其在swift中的情况**

---   


####五、控制流
自己添加：控制代码的执行流程

控制流的语句有4种

* 循环语句2种
    1. for：对于长度固定的遍历执行，有2种写法；一种常用的 for ..in ，一种常规的for
    2. while：对于长度不确定的遍历执行，有2种；一种while，一种repeat..while
* 条件语句2种
    1. 简单条件判断使用if
    2. 复杂条件判断使用switch。switch的值的匹配模式有
       1. 简单值模式，单一或若干相同的多个值
       2. 区间值模式
       3. Tuple模式
       4. 值绑定模式（常见Tuple类型数据）
       5. where语句
* 控制转移语句5种
* 提前结束语句guard
* 检测API版本


---
####六、函数
代码块，完成特定任务独立的代码块

* 函数的定义和使用
    1. func
    2. 名字
    3. 输入参数（个数、名称、类型）
    4. 输出参数（个数、类型）
* 参数与
    1. 个数（0..n），不确定个数（类似数组）
    2. 名字(默认、内外、忽略、指定)
    3. inout修饰符（使用条件）
    4. 默认规则（先后顺序、常变量）
* 返回值
    1. 个数（0..Tuple）、可选   
   
* 函数作为类型（由参数类型和返回类型组成）
    1. 作为类使用，同其他类一样使用
    2. 作为参数类型
    3. 作为返回类型
    4. 
* 嵌套函数



---

####七、闭包
自包含的函数代码块，全局和嵌套函数实际上也是特殊的闭包

* 闭包的3种形式
    1. 全局函数
    2. 嵌套函数
    3. 闭包表达式

* 表达式的优化(4种环境)
* 闭包表达式语法
    1. 参数和返回类型都在花括号之类
    2. 优化三步骤
* 尾随闭包（当表达式作为函数最后一个参数时，采用）
* 值捕获
   1. 即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。
* 闭包和函数是引用类型
* ***非逃逸闭包***
* ***自动闭包***


---

####八、枚举
为一组相关的值定义了一个共同的类型

* 创建枚举
   1. 值的类型有4种（Int、String、Double、Character）
   2. 关联值类型任意
   3. 不指定值类型，成员不会有隐式原始值
* 条件语句switch匹配枚举值
* 关联值
   1. 写法
   2. switch中关联值的提取let var
* 原始值（原值值定义后不会变，关联值可以变）
   1. 隐式赋值
   2. rawValue获取原始值
   3. 使用原始值初始化枚举，返回类型为optional
* **递归枚举**
   1. 样例掌握吃透

---

####九、类和结构体
构建代码所用的一种通用且灵活的构造体

* 类和结构体的相同点6个、不同点4个
* 它们的创建和使用（结构体特有逐一成员构造器）
* 结构体和枚举是值类型（基本数据类型都是值类型）
* 类是引用类型（引用类型的相等判断）
* 如何选择使用类和结构体（大多数使用类）
    1. 4种情况下使用结构体、并举3种实例
* 值类型在后台被编译器自动优化性能了

     
---

####十、属性
属性将值和特定的类、结构或枚举关联。分两类，（存储、计算）

* 存储属性
   1. 赋值：定义时，构造过程中
   2. 常量结构体的存储属性、可变方法
   3. 延迟存储属性
* 计算属性
   1. getter setter
   2. 只读计算属性
* 属性观察器
   1. 可以使用它的2种情况、和不能使用的2种情况
   2. willSet、didSet
* 全局变量和局部变量
   1. 定义
   2. 特性：延迟
* 类型属性
   1. 声明、注意事项 、使用


---
####十一、方法
与某些特定类型相关联的函数，它可以使用在类、结构体、枚举中，有实例方法和类型方法

* 实例方法
   1. 能访问它所属类型的所有其他实例方法和属性
   2. 不能脱离于实例而被使用
   3. 方法和函数的区别和联系
   4. 隐式self，不需要经常写
   5. 实例方法中修改值类型（结构体、枚举）使用mutating
   6. self赋值

* 类型方法



---
####十二、下标
定义在类、结构体、枚举中，是访问集合、列表、序列中元素的快捷方式

* 下标语法
* 下标用法：取决与使用场景
* 下标选项（参数）
   1. 参数数量、类型任意，返回值类型任意
   2. 可使用变量参数和可变参数
   3. 不能使用inout、默认值参数
   4. 下标可以实现多个，根据参数的数量和类型来区分它们的不同（重载）



----
####十三、继承
类类型专有的功能，可以用来区分它和其它类型，子类可以继承父类的属性、方法和其它特性

* 为了演示继承，定义一个基类
* 创建一个子类
* 子类可以为继承得来的实例属性、类型属性、实例方法、类方法、下标4种重新定制功能——即重写（override）
   1. 访问父类的属性、方法、下标：super
   2. 重写方法
   3. 重写属性，（不区分存储属性还是计算属性，常量属性和只读属性例外）提供getter、setter或者属性观察器
* 防止重写，把方法、属性、下标标记为final，或者类前面标识



---
####十四、构造过程
使用类、结构体、枚举类型的实例之前的准备过程。在实例可用之前必须执行这个过程。这个过程主要干的事情：确保每个存储属性有初始值；执行其他初始化工作

* 存储属性的初始赋值2种方式：默认值、构造器中赋值
* 自定义构造过程
    1. 输入参数和可选类型的属性来参与，
    2. 构造函数与方法的语法类似（外、内参数名称，不带外部名）
    3. 构造过程中可以修改常量，但不能在子类中再次修改它
* 默认构造器
   1. 结构体、类的所有属性都有默认值，同时没有自定义的构造器。类是无参构造器、结构体有2个其中一个特别的逐一成员构造器（无视属性有无默认值）
* 构造器代理（通过调用其它构造器来完成部分的构造过程）
   1. 值类型的构造器代理
        1. 无继承，简单，直接调用自己的其它构造器
        2. 一旦自定义构造器，就无法再访问默认构造器和逐一构造器（结构体）
        3. 如果你希望所有的构造器都能使用，请用extension来实现

   2. 类类型的构造器代理
        1. 类的构造器代理规则：3条
        2. 两段式构造过程，同时有4条规则确保这个过程不出错完成
        3. 两段式构造过程的规则流程描述
        4. 构造器的继承和重写
             1. 默认子类不会继承父类的构造器，但满足特定条件下可以
             2. 父类指定构造器可以被重写（写成指定构造器或者便利构造器），便利构造器不行，即便子类中的构造器和父类的一模一样
             3. 构造器的自动继承，2条规则
        5. 可失败的构造器
            1. 枚举类型的可以失败构造器
            2. 带原始值的枚举类型的可失败构造器
            3. 构造失败的传递
            4. 重写一个可失败构造器，可以重写成非可失败构造器。注意init！
        6. 必要构造器required，子类中不需要override
* 通过闭包或函数设置属性的默认值
    1. 闭包赋值时，注意此时实例还没完成初始化


----
####十五、析构过程
只使用用类类型，当一个实例被释放前，析构会被立即调用

* 析构过程原理
* 析构器的实践